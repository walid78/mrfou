Génération de code à partir des noeuds altarica élémentaires.

Etant donné que notre modèle altarica représente les comportements des éléments du système, nous allons ici faire le lien entre chaque comportement adopté par une entité et des portions de code implémentant ces comportements.


Moteurs.

event
    	back	OnFwd(Out_X, Y); pour le moteur X, et Y choisi arbitrairement entre 1 et 100.
    	stop	OnFwd(Out_X, 0);
    	forward	OnRev(Out_X, Y); pour le moteur X, et Y choisi arbitrairement entre 1 et 100.

La conjonction des évenements des 2 moteurs permettent de déplacer le robot de manière cohérente. Ceci correspond au noeud Moving.

Moving.

event
	stop	OnFwd(Out_AC, 0);
	left	OnFwd(Out_C, 20); et OnRev(Out_A, 20); ou bien RotateMotorEx(OUT_AC, 40, 180, -100, true, true); (plus simple)
	forward	OnFwd(Out_AC, 40);
	right	OnFwd(Out_A, 20); et OnRev(Out_C, 20); ou bien RotateMotorEx(OUT_AC, 40, 180, 100, true, true); (plus simple)
	halfturn	RotateMotorEx(OUT_AC, 40, 360, 100, true, true);


LightSensor.

flow
    value : [0,2];	value = SensorUs(3); 3 étant dans notre cas le numéro du port sur lequel est branché le capteur lumineux.


UltraSonic.

flow
    d : bool;	 value = SensorUs(4); 4 étant dans notre cas le numéro du port sur lequel est branché le capteur ultrason.


BlueTooth.

event

	orderFw				RemoteStartProgram(1,"forward.rxe"); 1 étant le numéro de fréquence sur lequel les robots sont réglés.
	orderLeft			RemoteStartProgram(1,"turnleft.rxe");
	orderRight			RemoteStartProgram(1,"turnright.rxe");
	orderStop			RemoteStopProgram(1);


	Les chaînes de caractères correspondent aux microprogrammes préenregistrés dans le contrôleur du robot esclave :

programme "forward.exe" :

task main (){
while(true){
 OnFwd(OUT_AC,30);
 }
}

programme "turnleft.exe" :

task main (){
 RotateMotorEx(OUT_AC, 40, 180, -100, true, true);		rotation à 90 degres à gauche.
}

programme "turnright.exe" :

task  main (){
 RotateMotorEx(OUT_AC, 40, 180, 100, true, true);		rotation à 90 degres à droite.
}


Controller.

Le principe de la translation entre code Altarica et code NXC est assez simple : les éléments que nous avons vu ci-dessus vont être utilisés pour former des blocs de code. Ainsi, pour chaque transition du controlleur, la garde sera contenue dans la garde d'un if, et les instructions correspondantes ainsi que les instructions obtenues en cascade par synchronisation de l'évènement en question seront dans le corps de ce même if.

trans
a |- b -> c
d |- e -> f

<b,e>

devient:

if(a){c; f;}

En effet, dans les modèles considérés, une garde de transition découlant d'une synchronisation est toujours à true. Si l'on veut considérer une garde non triviale, alors il faudra ajouter un if imbriqué pour la seconde transition.

Les changements de variables altarica seront reproduits en NXC avec des variables identiques. Le système considéré devant être réactif, une boucle de type while(true) encapsulera l'ensemble du code concernant la prise de décision et le déclenchement de comportements en conséquence.

Exemple concret :


    light.value = 2 & 
    sonic.d &
    last_val = 1 &
    not obstacle_mode	     |- go -> last_val := 2, 
    			     	      changed_square := true;
  
sync
    <go, BT.orderStop, move.forward>;

devient:

if(SensorUs(3) == BLANC && SensorUs(4) == true && current_square == GRIS && !obstacle_mode)
{
// partie instructions de la transition
current_square = BLANC;
changed_square = true;

// instructions découlant de la synchronisation
RemoteStopProgram(1);
OnFwd(Out_AC, 40);
}

Cependant, certains problèmes purement techniques exigent des modifications et ajustements locaux dans le code, qui ne sont pas prévus à l'origine dans le modèle. Exemple : problème de lecture de gris lors du passage d'une case blanche à une case noire (voir section problèmes).


