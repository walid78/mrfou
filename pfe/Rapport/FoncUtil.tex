\section{R\'{e}duction API NXC}
Pour la r\'{e}alisation du  projet nous utiliserons 4 cat\'{e}gories de fonction : celles relatives aux moteurs, aux capteurs , à la connexion Bluetooth et \'{e}ventuellement d'autres fonctions permettant la coh\'{e}sion de l'ensemble.

\subsection{Les moteurs }
\begin{verbatim}
	OnFwd("port","power"); //permet de mettre en marche "avant" un moteur du robot 
	OnRev("port","power"); //sens inverse
	RotateMotor("port","speed","degrees"); //
	RotateMotorEx("port","speed","degrees","turnpct","sync","stop"); 
\end{verbatim}

\subsection{Les capteurs }

\subsubsection{Type et mode des capteurs}
\begin{verbatim}
	SetSensorLight("port"); //Lie le capteur de lumière à un "port"
	SetSensorSound("port"); //Lie le capteur ultrason à un "port"
	SetSensorMode("port","const mode"); //Configure le mode du capteur associé au "port"
	SetInput("port","const field","value"); //Configure le type du capteur associé au "port"
	SetSensorLowspeed("port"); //Configure le capteur en mode I2C
	ClearSensor("port"); //Efface la valeur d'un capteur associé à un "port"

\end{verbatim}

\subsubsection{Information des capteurs}
\begin{verbatim}
	Sensor("n"); //retourne la valeur d'un capteur
	SensorUS("n"); //retourne la valeur du capteur ultrason

\end{verbatim}

\subsection{La connexion Bluetooth }
\begin{verbatim}
	BluetoothStatues("NUMBER"); //Vérifie la connexion
	RemoteStartProgram("connection", "filename");
	RemoteStopProgram("connection");

\end{verbatim}

\subsection{Autres fonctions }
\begin{verbatim}
	Wait("time"); //Temps donné à l'exécution d'une action
	off("port"); //Stop le moteur associé au "port"
	Precedes("task1","task2","taskn"); //Permet l'exécution de taches simultané

\end{verbatim}

\subsection{Les variables }
\begin{verbatim}
	OUT_A; //port A
	OUT_AC; //port AC
	IN_1; //Input 1
	IN_2; //Input 2

\end{verbatim}

\section{Implémentation}

\subsection{Le langage NXC}

Le langage NXC est un langage calqué sur le C d'où il tire d'ailleurs son
sigle, Not eXactly C. Il est ce que l'on peut appeler une surcouche du
langage utilisé par les robots  : le langage NBC (Next Byte Code). Bien
que celui-ci possède une API assez developpée, ça syntaxe s'inspirant
fortement de l'assembleur n'en reste pas moins rude et c'est pour cela
que nous préfèrerons programmer les robots  dans le langage NXC.


\subsection{Algorithme}


L'algorithme utilisé dans le robot maître est assez simple à comprendre
en lui même. La difficulté rencontré vient donc plus de l'approche de la
programmation du robot.
\\
Pour rapidement décrire l'algorithme, nous avons en premier lieu un while nous
permettant de boucler à l'infini. Dans celui-ci le capteur de lumière
vient mettre à jour une variable, current\_val, qui indique la couleur de la prochaine
case rencontrée par le robot.

\begin{verbatim} 
 while(current_val == last_val){
   last_val = current_val ;
   real_val = Sensor(S3);
  if((real_val>=MIN_GRIS) && (real_val<=MAX_GRIS))
    current_val = GRIS;
  else{
    if((real_val>=MIN_BLANC) && (real_val<=MAX_BLANC))
     current_val = BLANC;
     else if((real_val>=MIN_NOIR) && (real_val<=MAX_NOIR))
       current_val = NOIR;
      }
  } 
\end{verbatim}

Le robot maître avance ensuite jusqu'à la prochaine case. En fonction de la
couleur de celle-ci, deux cas se présentent.
Si elle est grise ou blanche, le robot maître s'arrète et ordonne au
robot esclave d'avancer jusqu'à lui.

\begin{verbatim}
if((changed_square == true) && (obstacle_mode == false))
{
 OnFwd(OUT_AC,0);
 RemoteStartProgram(1,"forward.rxe");
 while(SensorUS(S4) > 10);
 RemoteStopProgram(1);
 OnFwd(OUT_AC,30);
}
\end{verbatim}

Si elle est noire, le robot maître effectue l'opération de contournement
de l'obstacle.

\begin{verbatim} 
if((current_val == NOIR)){
 if(obstacle_mode == FALSE){
 TextOut(10,LCD_LINE4,"NOIR 1");
 obstacle_mode = TRUE;
 OnFwd(OUT_AC,0);
 RotateMotorEx(OUT_AC, 30, 220, -100, true, true);
 }else{
    turned_to_right = TRUE;
    TextOut(10,LCD_LINE5,"NOIR 2");
    OnFwd(OUT_AC,0);
    RotateMotorEx(OUT_AC, 30, 400, 100, true, true);
    obstacle_mode = FALSE;
    }
}
\end{verbatim}

Il ordonne ensuite au robot esclave d'avancer et tourner dans le même
sens. 

\begin{verbatim}
if(found_way == TRUE){
  if(turned_to_right == TRUE){
   OnFwd(OUT_AC,30);
   Wait(3000);
   OnFwd(OUT_AC,0);
  }
  RemoteStartProgram(1,"forward.rxe");
  while(SensorUS(S4) > 10);
  RemoteStopProgram(1);
 
  Wait(2000);
 
  if(turned_to_right == FALSE){
   RemoteStartProgram(1,"turnleft.rxe");
   Wait(5000);
   RemoteStopProgram(1);
  }
  else{
     RemoteStartProgram(1,"turnright.rxe");
     Wait(5000);
     RemoteStopProgram(1);
     }
  found_way = FALSE;
  OnFwd(OUT_AC,30);
  }
\end{verbatim}

Les deux robots recommencent ensuite le même cycle de fonctionement.
