node Controller
  sub
    light: LightSensor;
    sonic: UltraSonicSensor;
    move: Moving;
    BT: BTMaster;
  state

    //Dernière case vue
    /*
     * 0 : noire
     * 1 : grise
     * 2 : blanche
     */
    last_val : [0,2];

    //Le maître a-t-il changé de case ?
    changed_square: bool;

    //Le maître vient-il de rencontrer un obstacle ?
    obstacle_mode : bool;

    //Le robot maître a-t-il trouvé le bon chemin à chosir après un obstacle ?
    found_way : bool;

    //Le maître a-t-il tourné à droite ? (si non à gauche)
    turned_to_right : bool;

    //Le maître s'est-il décalé pour laisser la place à l'esclave ?
    slave_has_place : bool;

  event

    go, waitingSlaveOneSquare, wallFront, foundLeft, halfTurn, foundRight,
    makePlace, slaveTurnLeft, slaveTurnRight; 
    
      
  trans

    /* Procédure utilisée dans le code pour avancer:
     *
     * Le maitre avance d'une case, il s'arrete, attend l'esclave qui avance, 
     * lorsque l'ultrasonic le capte, l'esclave s'arrete, le maitre avance 
     * d'une case et ainsi de suite.
     *
     * Procédure utilisée dans le code pour tourner à gauche après avoir 
     * rencontré un mur, et pas d'obstacle à gauche:
     *
     * Le maitre avance d'une case, et detecte une case noire. Il s'arrete et 
     * l'esclave s'arrete aussi. Le maître tourne de 90 degrés à gauche et 
     * avance d'une case, s'arrete, et attend. Il donne l'ordre à l'esclave
     * d'avancer jusqu'à le sentir derriere, lui ordonne de tourner à gauche,
     * et la procédure ligne droite recommence.
     * 
     */
  
    /* Le maitre voit une case blanche, l'esclave est derriere lui. On dit à
     * l'esclave de stopper via le bluetooth (dans les synchronisations), le 
     * maitre avance, passe sur cette case blanche, on passe le booléen qui 
     * indique que l'on vient vient de changer de case à vrai.  Les gardes 
     * vérifient bien sur que la derniere case vue était une case grise, 
     * que l'esclave est derriere, et que le maitre n'est pas 
     * en mode obstacle. */

    light.value = 2 & 
    sonic.d &
    last_val = 1 &
    not obstacle_mode	     |- go -> last_val := 2, 
    			     	      changed_square := true;
  
  
    /* Le maitre voit une case grise, l'esclave est derriere lui. On dit à
     * l'esclave de stopper via le bluetooth (dans les synchronisations), le 
     * maitre avance, passe sur cette case grise, on passe le booléen qui 
     * indique que l'on vient de changer de case à vrai. Les gardes 
     * sont adaptées au changement de couleur.*/
     
     
    light.value = 1 & 
    sonic.d & last_val = 2 &
    not obstacle_mode	     |- go -> last_val := 1, 
    				      changed_square := true;

  
    /* Cet événement correspond au maitre qui s'arrete, après avoir changé de
     * case, pour attendre l'esclave. Le maitre s'arrete, ordonne à l'esclave
     * d'avancer, et on indique via le booléen changed_square que le changement 
     * de case est fait. */

    changed_square & 
    not obstacle_mode & 
    not sonic.d	        |- waitingSlaveOneSquare -> changed_square := false;
  

    /* Voici le premier evenement qui signale la présence d'un obstacle, en 
     * l'occurence un seul mur en face du robot, alors qu'il n'avait pas déjà
     * rencontré un obstacle au moment précédent : le robot maître passe alors
     * en mode obstacle, passe changed_square à false, dit à l'esclave de
     * s'arrêter et tourne à gauche. */

    light.value = 0 &
    sonic.d & 
    (last_val = 1 | 
     last_val = 2) & 
    not obstacle_mode	    |- wallFront -> obstacle_mode := true, 
    			       		    changed_square := false;

    /* À cette étape là, le maître trouve une case de sortie à gauche après
     * avoir été en mode obstacle. 
     */

    // Le maître était sur une case blanche
    obstacle_mode &
    light.value = 2 &
    last_val = 1 &
    not found_way &
    not turned_to_right     |- foundLeft -> found_way := true,
    			   	     	    changed_square := true,
					    last_val := 2;

    // Le maître était sur une case grise
    obstacle_mode &
    light.value = 1 &
    last_val = 2 &
    not found_way &
    not turned_to_right     |- foundLeft -> found_way := true,
    			   	     	    changed_square := true,
					    last_val := 1;


    /* Si le maître retombe sur un obstacle à gauche, alors il sait que la 
     * sortie est plutot à droite. 
     */

    obstacle_mode &
    light.value = 0 &
    not turned_to_right	    |- halfTurn -> turned_to_right := true;

    /* Le maître vient de tourner à droite et est prêt à prendre la sortie. 
     */

    obstacle_mode &
    turned_to_right &
    not found_way &
    light.value != last_val |- foundRight -> found_way := true,
    		      	 	    		     changed_square := true,
						     last_val := light.value;


    /* Maintenant le maître a avancé d'une case pour laisser la place à 
     * l'esclave, ce dernier peut donc avancer.
     */

     obstacle_mode &
     found_way &
     not slave_has_place &
     not sonic.d &
     light.value != last_val |- makePlace -> slave_has_place := true;
     

    /* Voici la dernière étape du mode obstacle. Dès que le maître détecte
     * l'esclave dans son champ, il le fait se tourner dans le même sens que 
     * lui et sort du mode obstacle.
     */

    //Si le maître a tourné à gauche
    obstacle_mode &
    found_way &
    sonic.d &
    slave_has_place &
    not turned_to_right |- slaveTurnLeft -> obstacle_mode := false,
    			   		    found_way := false,
					    turned_to_right := false,
					    slave_has_place := false;


    //Si le maître a tourné à droite
    obstacle_mode &
    found_way &
    sonic.d &
    slave_has_place &
    turned_to_right |- slaveTurnRight -> obstacle_mode := false,
    			   		 found_way := false,
					 turned_to_right := false,
					 slave_has_place := false;


  sync
    <go, BT.orderStop, move.forward>;
    <waitingSlaveOneSquare, BT.orderFw, move.stop>;
    <wallFront, BT.orderStop, move.left>;
    <foundLeft, BT.orderStop, move.forward>;
    <halfTurn, BT.orderStop, move.halfturn>; 
    <foundRight, BT.orderStop, move.forward>;
    <makePlace, BT.orderFw, move.stop>;
    <slaveTurnLeft, BT.orderLeft, move.stop>;
    <slaveTurnRight, BT.orderRight, move.stop>;

  init
//    light.value := 2;
    last_val := 1;
    changed_square := false;
    obstacle_mode := false;
    found_way := false;
    turned_to_right := false;
    slave_has_place := false;
edon
