  \subsection{Question 2}
  Le but ici est de faire la comparaison entre l'algorithme du projet vu
  dans la question précédente (\ref{part2q1} page \pageref{part2q1}) et
  l'algorithme vu en cours basé sur un couplage maximum.

  Pour comparer ces deux algorithmes, nous allons mesurer leur temps
  d'exécution ainsi que la taille de la couverture trouvée. Le résultat
  de ces mesures se trouve dans le tableau \ref{tableau} page
  \pageref{tableau}. Toutes les comparaisons sont faites sur trois
  graphes\footnote{Graphes fournis dans le répertoire jeuxRapport} :
  \emph{ex32-12.gin, testTree1000.gin, testTree100.gin}.

  Le calcul des temps d'exécution se fait à l'aide des fichiers
  \emph{timing.cc} et \emph{timing.h} que nous avons récupérés des
  projets
  \emph{Padico\footnote{\url{http://gforge.inria.fr/projects/padico}}} 
  et \emph{Adage\footnote{\url{http://gforge.inria.fr/projects/adage}}}
  de l'\emph{INRIA.}
 
  \begin{figure}[!ht]
   \begin{center}
    \begin{tabular}{|c|c|c||c|c||c|c|}
     \cline{2-7}
     \multicolumn{1}{c|}{} & \multicolumn{2}{|c||}{ex32-12.gin}
     &\multicolumn{2}{|c||}{testTree100.gin} &
     \multicolumn{2}{|c|}{testTree1000.gin}\\ 
     \cline{2-7}
     \multicolumn{1}{c|}{} & algoP & algoC & algoP & algoC & algoP &
     algoC\\
     \hline
     Temps d'execution(en $\mu$s) & 58.5808 & 1.12014 & 400.344 &
     5.82175 & 3911.25 & 56.8837\\
     \hline
     Taille de la couverture & 8 & 14 & 38 & 58 & 365 & 576\\
     \hline
     Taille couverture optimale & \multicolumn{2}{|c||}{7} &
		 \multicolumn{2}{|c||}{31} &
     \multicolumn{2}{|c||}{325}\\ 
     \hline
    \end{tabular}
    \caption{Tableau comparatif des exécutions des plusieurs
    exemples (algoP: Algorithme du projet et algoC: Algorithme par
    couplage maximum).\label{tableau}} 
   \end{center}
  \end{figure}  

  On peut constater sur le tableau \ref{tableau} page \pageref{tableau}
  que le temps d'exécution de l'algorithme du couplage maximum est bien
  plus rapide que l'algorithme du projet. Pour le graphe de taille 1000,
  le temps d'exécution est $70$ fois plus rapide pour l'algorithme de
  couplage.

  Néanmoins, si l'on compare la taille des couvertures retournées, on
  constate que l'algorithme du projet est bien meilleur. On voit que sur
  un graphe à 1000 sommets, ce dernier trouve une converture à $365$
  sommets contre $576$ pour l'autre. De plus, les tests étant réalisés
  sur différents types de graphes, et notamment \emph{ex32-12.gin,
  testTree1000.gin, testTree100.gin} qui sont des arbres, que plus le
  graphe comportera de cycles et aura beaucoup de feuilles (des graphes
  assez développés quand même car un graphe étoile n'irai pas), plus la
  différence entre les deux algorithmes se fera sentir.
