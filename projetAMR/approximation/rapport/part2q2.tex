  \subsection{Question 2}
  Le but ici est de faire la comparaison entre l'algorithme du projet vu
  dans la question précédente (\ref{part2q1} page \pageref{part2q1}) et
  l'alogorithme vu en cours basé sur un couplage maximum.\newline
  \indent L'algorithme du couplage maximum est implémenté dans le fichier
  \emph{Graph.cpp} par la méthode \emph{coverCourses()} et l'algorithme
  du projet est implémenté dans \emph{Tree.cpp} par la méthode
  \emph{coverProject()} et la fonction \emph{coverProject\_aux()}.\newline
  \indent Pour comparer ces deux algorithmes, nous allons mesurer leur
  temps d'exécution et surtout la taille de la couverture trouvée. Le
  résultat de ces mesures se trouve dans le tableau \ref{tableau}
  page \pageref{tableau}. Toutes les comparaisons sont faites sur trois
  graphes: \emph{ex32-12.gin, testTree1000.gin, testTree100.gin}.\newline
  \indent Le calcul des temps d'exécution ce fait à l'aide des fichiers
  \emph{timing.cc} et \emph{timing.h} que nous avons récupérés des
  projets \emph{Padico\footnote{\url{http://gforge.inria.fr/projects/padico}}}
  et \emph{Adage\footnote{\url{http://gforge.inria.fr/projects/adage}}} de
  l'\emph{INRIA.}\newline

  \begin{figure}[!ht]
   \begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|}
     \cline{2-7}
     \multicolumn{1}{c|}{} & \multicolumn{2}{|c|}{ex32-12.gin}
     &\multicolumn{2}{|c|}{testTree100.gin} &
     \multicolumn{2}{|c|}{testTree1000.gin}\\ 
     \cline{2-7}
     \multicolumn{1}{c|}{} & algoP & algoC & algoP & algoC & algoP &
     algoC\\
     \hline
     Temps d'execution(en $\mu$s) & 12.37 & 81.97 & 65.56 & 1109.77 &
     696.49 & 66723.1\\
     \hline
     Taille de la couverture & 8 & 14 & 38 & 58 & 365 & 576\\
     \hline
    \end{tabular}
    \caption{Tableau comparatif des exécutions des plusieurs
    exemples (algoP: Algorithme du projet et algoC: Algorithme par
    couplage maximum).\label{tableau}} 
   \end{center}
  \end{figure}  

  On peut constater sur le tableau \ref{tableau} page \pageref{tableau}
  le temps d'exécution de l'algorithme du couplage maximum est bien plus
  long que l'alogoritme du projet. Pour le graphe de taille 1000, le
  temps d'exécution est $95$ fois plus rapide pour l'algorithme du
  projet. Il faut toutefois faire attention à ce chiffre car
  l'implémentation de notre structure de graphe n'est pas optimisée pour
  la suppression des arêtes ce qui ne nous permet pas de faire une
  comparaison précise.\newline
  \indent Néanmoins, si l'on compare la taille des couvertures
  retounées, on constate que là aussi l'algorithme du projet est bien
  meilleur. On voit que sur un graphe à 1000 sommets, ce dernier trouve
  une converture à $365$ sommets contre $576$ pour l'autre. De plus, les
  tests étant réalisés sur différents types de graphes, et notemment
  \emph{ex32-12.gin, testTree1000.gin, testTree100.gin} qui sont des
  arbres, que plus le graphe comportera un minimum de cycle et aura
  beaucoup de feuilles (des graphe assez développé quand même car un
  graphe étoile n'irai pas), plus la différence entre les deux
  algorithmes se faira sentir. 